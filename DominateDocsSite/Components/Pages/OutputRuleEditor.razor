@using MudBlazor
@using DominateDocsData.Models
@using DominateDocsData.Models.RulesEngine
@using System.Reflection
@inject IDialogService DialogService

<MudPaper Elevation="0" Outlined="true" Class="pa-3 mb-4">

    <div class="d-flex justify-space-between align-center mb-2">
        <MudText Typo="Typo.subtitle2">If</MudText>

        <MudIconButton Icon="@Icons.Material.Filled.DeleteOutline"
                       Color="Color.Error"
                       Size="Size.Small"
                       OnClick="@(() => OnRemoveRequested.InvokeAsync())" />
    </div>

    <RuleGroupEditor Title=""
                     Group="Rule.If"
                     Fields="RuleGroupFields"
                     FieldValues="RuleGroupFieldValues"
                     OnChanged="OnRuleChanged" />

    <MudDivider Class="my-3" />

    <MudText Typo="Typo.subtitle2" Class="mb-2">Then Generate</MudText>

    <div class="d-flex flex-wrap align-center" style="gap:8px;">
        @foreach (var docId in (Rule.ThenGenerateDocumentIds ?? new List<Guid>()))
        {
            <MudChip T="string"
                     Size="Size.Small"
                     Variant="Variant.Outlined"
                     Closeable="true"
                     OnClose="@(() => RemoveThenDoc(docId))">
                @GetDocName(docId)
            </MudChip>
        }

        <MudLink Href="javascript:void(0)"
                 Typo="Typo.body2"
                 OnClick="@OpenThenDocsPicker">
            Select Documents
        </MudLink>
    </div>

</MudPaper>

@code {
    [Parameter, EditorRequired] public OutputRule Rule { get; set; } = default!;

    // ✅ Force the correct Document type
    [Parameter, EditorRequired]
    public IReadOnlyList<DominateDocsData.Models.DTOs.DocumentListDTO> MasterDocumentDTOs { get; set; } = Array.Empty<DominateDocsData.Models.DTOs.DocumentListDTO>();

    [Parameter, EditorRequired]
    public IReadOnlyList<(string Key, string Label)> Fields { get; set; } = Array.Empty<(string, string)>();

    [Parameter, EditorRequired]
    public IReadOnlyDictionary<string, IReadOnlyList<(string Display, string Value)>> FieldValues { get; set; } = new Dictionary<string, IReadOnlyList<(string, string)>>();

    [Parameter] public EventCallback OnRemoveRequested { get; set; }

    [Parameter] public EventCallback OnChanged { get; set; }

    private IEnumerable<string> RuleGroupFields => (Fields ?? Array.Empty<(string Key, string Label)>()).Select(f => f.Key);

    private IDictionary<string, IEnumerable<string>> RuleGroupFieldValues =>
        (FieldValues ?? new Dictionary<string, IReadOnlyList<(string Display, string Value)>>())
            .ToDictionary(
                kvp => kvp.Key,
                kvp => (IEnumerable<string>)(kvp.Value?.Select(x => x.Value) ?? Enumerable.Empty<string>())
            );

    private string GetDocName(Guid id)
    {
        var doc = MasterDocumentDTOs.FirstOrDefault(X => X.Id == id);

        string name = doc is not null ? doc.Name : "Unknown Document";

        return name;
    }

    private void RemoveThenDoc(Guid docId)
    {
        Rule.ThenGenerateDocumentIds ??= new List<Guid>();
        Rule.ThenGenerateDocumentIds.Remove(docId);
        _ = OnChanged.InvokeAsync();
    }

    private async Task OpenThenDocsPicker()
    {
        Rule.ThenGenerateDocumentIds ??= new List<Guid>();
        var selected = new HashSet<Guid>(Rule.ThenGenerateDocumentIds);

        IDialogReference? dialogRef = null;

        var parameters = new DialogParameters
        {
            ["Title"] = "Select Documents to Generate",
            ["AllDocuments"] = MasterDocumentDTOs,
            ["SelectedIds"] = selected,

            // ✅ Caller controls close behavior (works even when no MudDialogInstance exists)
            ["OnCancel"] = (Action)(() =>
            {
                if (dialogRef is not null)
                    dialogRef.Close(DialogResult.Cancel());
            }),

            ["OnApply"] = (Action<HashSet<Guid>>)((HashSet<Guid> picked) =>
            {
                if (dialogRef is not null)
                    dialogRef.Close(DialogResult.Ok(picked));
            })
        };

        var options = new DialogOptions { CloseButton = true, FullWidth = true, MaxWidth = MaxWidth.Medium };

        dialogRef = DialogService.Show<DocumentPickerDialog>("Select Documents", parameters, options);

        var result = await dialogRef.Result;

        if (!result.Canceled && result.Data is HashSet<Guid> picked)
        {
            foreach (var id in picked.Where(x => x != Guid.Empty).Distinct().ToList())
            {
                if (!Rule.ThenGenerateDocumentIds.Contains(id)) Rule.ThenGenerateDocumentIds.Add(id);
            }
                       
            await OnChanged.InvokeAsync();
        }
    }

    private Task OnRuleChanged() => OnChanged.InvokeAsync();

    
    
}

