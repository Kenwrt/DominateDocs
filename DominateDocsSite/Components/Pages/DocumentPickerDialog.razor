@using MudBlazor
@using System.Reflection

<MudDialog>
    <DialogContent>
        <MudText Typo="Typo.h6" Class="mb-2">@Title</MudText>

        <MudTextField @bind-Value="_search"
                      Placeholder="Search..."
                      Variant="Variant.Outlined"
                      Dense="true"
                      Immediate="true"
                      Class="mb-3"
                      Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Filled.Search" />

        <MudPaper Outlined="true" Class="pa-2" Style="max-height:420px; overflow:auto;">
            @foreach (var doc in AllDocuments.Where(x => !SelectedIds.Contains(x.Id)).ToList())
            {
                
                if (doc.Id == Guid.Empty)
                    continue;

                @* <MudCheckBox T="bool"
                             Label="@doc.Name"
                             Value="@SelectedIds.Contains(doc.Id)"
                             ValueChanged="@((bool isChecked) => OnCheckedChanged(doc.Id, isChecked))" /> *@

                <MudChip T="string" Clickable="true"
                             Variant="Variant.Outlined"
                             Color="Color.Default"
                             OnClick="@(() => SelectDoc(doc.Id))"
                             Class="ma-1">
                        <MudIcon Icon="@Icons.Material.Filled.Add" Size="Size.Small" Class="me-1" />
                        @doc.Name
                    </MudChip>
                
            }
        </MudPaper>
    </DialogContent>

    <DialogActions>
        <MudButton Variant="Variant.Text" OnClick="Cancel">Cancel</MudButton>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="Apply">Apply</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter] public string Title { get; set; } = "Select Documents";

    // ✅ Force the correct Document type (data model)
    [Parameter] public IReadOnlyList<DominateDocsData.Models.DTOs.DocumentListDTO> AllDocuments { get; set; } = Array.Empty<DominateDocsData.Models.DTOs.DocumentListDTO>();

    [Parameter] public HashSet<Guid> SelectedIds { get; set; } = new();

    // ✅ NEW: caller-provided callbacks that actually close the dialog using the IDialogReference
    [Parameter] public Action<HashSet<Guid>>? OnApply { get; set; }
    [Parameter] public Action? OnCancel { get; set; }

    private string _search = string.Empty;

    private bool docIsChecked; // <-- DON'T do this in a foreach (see note below)

    // private IEnumerable<DominateDocsData.Models.DTOs.DocumentListDTO> FilteredDocs
    // {
    //     get
    //     {
    //         if (AllDocuments is null || AllDocuments.Count == 0)
    //             return Enumerable.Empty<DominateDocsData.Models.DTOs.DocumentListDTO>();

    //         if (string.IsNullOrWhiteSpace(_search))
    //             return AllDocuments;

    //         var term = _search.Trim();

    //         AllDocuments = AllDocuments.Where(x => !SelectedIds.Contains(x.Id)).ToList();

    //         return AllDocuments.Where(d =>
    //         {
    //              var name = d.Name;
    //             //var name = GetDocumentDisplayName(d);
    //             return !string.IsNullOrWhiteSpace(name) && name.Contains(term, StringComparison.OrdinalIgnoreCase);
    //         });
    //     }
    // }

    private void Toggle(Guid id, bool isChecked)
    {
        if (isChecked) SelectedIds.Add(id);
        else SelectedIds.Remove(id);
    }

    private void OnCheckedChanged(Guid id, bool isChecked)
    {

        if (isChecked) SelectedIds.Add(id);
        else SelectedIds.Remove(id);

    }

    private void SelectDoc(Guid id)
    {
        // Clicking a chip means "select it" (it will disappear because the list filters SelectedIds out).
        if (!SelectedIds.Contains(id)) SelectedIds.Add(id);
    }

    private void Cancel()
    {
        // Caller closes the dialog. We just signal intent.
        OnCancel?.Invoke();
    }

    private EventCallback<bool> CreateCheckedChanged(Guid id) => EventCallback.Factory.Create<bool>(this, isChecked => Toggle(id, isChecked));

    private void Apply()
    {
        // Caller closes the dialog and returns data.
        OnApply?.Invoke(new HashSet<Guid>(SelectedIds));
    }

    // --------- Document model drift helpers ---------

    private static Guid GetDocumentId(DominateDocsData.Models.Document doc)
    {
        foreach (var name in new[] { "Id", "DocumentId", "_id" })
        {
            var prop = doc.GetType().GetProperty(name, BindingFlags.Public | BindingFlags.Instance);
            if (prop is null) continue;

            var val = prop.GetValue(doc);
            if (val is Guid g && g != Guid.Empty) return g;

            if (val is string s && Guid.TryParse(s, out var parsed) && parsed != Guid.Empty)
                return parsed;
        }

        return Guid.Empty;
    }

    // private static string GetDocumentDisplayName(DominateDocsData.Models.Document doc)
    // {
    //     foreach (var name in new[] { "Name", "Title", "DisplayName", "DocumentName", "FileName" })
    //     {
    //         var prop = doc.GetType().GetProperty(name, BindingFlags.Public | BindingFlags.Instance);
    //         if (prop is null) continue;

    //         if (prop.GetValue(doc) is string s && !string.IsNullOrWhiteSpace(s))
    //             return s;
    //     }

    //     var id = GetDocumentId(doc);
    //     return id == Guid.Empty ? "(Unnamed Document)" : id.ToString();
    // }
}
