@using MudBlazor
@using DominateDocsData.Models.DTOs

<MudDialog Class="doc-picker">
    <DialogContent>
        <MudText Typo="Typo.h6" Class="mb-2">@Title</MudText>

        <MudTextField @bind-Value="_search"
                      Placeholder="Search..."
                      Variant="Variant.Outlined"
                      Dense="true"
                      Immediate="true"
                      Class="mb-3"
                      Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Filled.Search" />

        <MudPaper Outlined="true" Class="pa-2" Style="max-height:420px; overflow:auto;">
            @foreach (var doc in FilteredDocs)
            {
                <MudChip T="string"
                         Clickable="true"
                         Variant="Variant.Outlined"
                         Color="Color.Default"
                         OnClick="@(() => SelectDoc(doc.Id))"
                         Class="ma-1">
                    <MudIcon Icon="@Icons.Material.Filled.Add" Size="Size.Small" Class="me-1" />
                    @doc.Name
                </MudChip>
            }

            @if (!FilteredDocs.Any())
            {
                <MudText Typo="Typo.caption" Class="pa-2 mud-text-secondary">
                    No documents match your search.
                </MudText>
            }
        </MudPaper>
    </DialogContent>

    <DialogActions>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="Close">
            Close
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    // v8-safe dialog instance
    [CascadingParameter] private IMudDialogInstance Dialog { get; set; } = default!;

    [Parameter] public string Title { get; set; } = "Select Documents";

    [Parameter] public IReadOnlyList<DocumentListDTO> AllDocuments { get; set; } = Array.Empty<DocumentListDTO>();

    // Used for filtering (so selected docs disappear)
    [Parameter] public HashSet<Guid> SelectedIds { get; set; } = new();

    // NEW: immediate select behavior
    [Parameter] public Action<Guid>? OnSelected { get; set; }

    // LEGACY COMPAT (so older callers don't crash)
    // They might not be used visually anymore, but they must exist.
    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public EventCallback<HashSet<Guid>> OnApply { get; set; }

    private string _search = string.Empty;

    private IEnumerable<DocumentListDTO> FilteredDocs
    {
        get
        {
            IEnumerable<DocumentListDTO> q =
                AllDocuments.Where(d => d.Id != Guid.Empty && !SelectedIds.Contains(d.Id));

            if (!string.IsNullOrWhiteSpace(_search))
            {
                var term = _search.Trim();
                q = q.Where(d => !string.IsNullOrWhiteSpace(d.Name) &&
                                 d.Name.Contains(term, StringComparison.OrdinalIgnoreCase));
            }

            return q;
        }
    }

    private void SelectDoc(Guid id)
    {
        if (id == Guid.Empty)
            return;

        // Make it disappear from the list
        if (!SelectedIds.Contains(id))
            SelectedIds.Add(id);

        // Immediate callback (your desired behavior)
        OnSelected?.Invoke(id);

        StateHasChanged();
    }

    private async Task Close()
    {
        // If old code expects an OnCancel callback, fire it.
        if (OnCancel.HasDelegate)
            await OnCancel.InvokeAsync();

        Dialog.Close();
    }

    // Not shown in UI, but kept for legacy compatibility if any code calls it directly.
    private async Task Apply()
    {
        if (OnApply.HasDelegate)
            await OnApply.InvokeAsync(SelectedIds);

        Dialog.Close();
    }
}
